<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Pr√°tica e Otimiza√ß√£o em SQL/PLSQL</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
</head>

<body>
  <div class="overlay" id="overlay"></div>

  <button class="hamburger-menu" id="hamburger-menu">
    <i class="fas fa-bars"></i>
  </button>

  <div class="sidebar" id="sidebar">
    <h2>PL/SQL üöÄ</h2>
    <a href="index.html"><i class="fas fa-home"></i> <span>In√≠cio</span></a>
    <a href="Conceitos BD.html"><i class="fas fa-book"></i> <span>Conceitos
        BD</span></a>
    <a href="SQL Essencial.html"><i class="fas fa-code"></i> <span>SQL Essencial</span></a>
    <a href="SQL - Fundamentos Avan√ßados.html"><i class="fas fa-database"></i> <span>SQL Fundamentos
        Avan√ßados</span></a>
    <a href="SQL - Agregacao e Subconsultas.html"><i class="fas fa-calculator"></i> <span>Agrega√ß√£o e
        Subconsultas</span></a>
    <a href="SQL - DDL Avancado e objetos.html"><i class="fas fa-cogs"></i> <span>SQL DDL Avan√ßado</span></a>
    <a href="Pr√°tica e Otimiza√ß√£o.html"><i class="fas fa-chart-line"></i> <span>Pr√°tica e Otimiza√ß√£o</span></a>
    <a href="PLSQL - Fundamentos e Estruturas de Controle.html"><i class="fas fa-file-code"></i> <span>PL/SQL
        Fundamentos</span></a>
    <a href="SQL Programacao.html"><i class="fas fa-cogs"></i><span>PL/SQL Programa√ß√£o</span></a>
    <a href="PLSQL - Tratamento de Excecoes e Pacotes.html"><i class="fas fa-boxes"></i> <span>PL/SQL Exce√ß√µes e
        Pacotes</span></a>
    <a href="Extras - PL_SQL Avan√ßado.html"><i class="fas fa-plus-circle"></i> <span>PL/SQL Avan√ßado</span></a>
  </div>

  <div class="content" id="content">
    <header>
      <h1>Pr√°tica e Otimiza√ß√£o em SQL/PLSQL</h1>
      <p>Dominando a arte de escrever consultas eficientes e otimizar o desempenho do seu c√≥digo no Oracle.</p>
    </header>

    <div class="main-section">

      <div class="sub-section">
        <h2>1Ô∏è‚É£ Boas Pr√°ticas na Escrita SQL <i class="fas fa-magic"></i></h2>
        <blockquote>
          <p>Escrever SQL claro e eficiente √© o primeiro passo para garantir um bom desempenho. Lembre-se que um banco
            de dados grande amplifica os efeitos de um c√≥digo mal escrito.</p>
        </blockquote>
        <div class="card">
          <ul>
            <li><strong>Use <code>WHERE</code> para Filtrar Cedo:</strong> Sempre que poss√≠vel, utilize a cl√°usula
              <code>WHERE</code> para reduzir o n√∫mero de linhas processadas o mais cedo poss√≠vel.
            </li>
            <li><strong>Evite <code>SELECT *</code>:</strong> Selecione apenas as colunas de que voc√™ realmente precisa.
              Isso reduz o tr√°fego de rede, o uso de mem√≥ria e a carga de I/O.</li>
            <li><strong>Indexa√ß√£o Adequada:</strong> Crie √≠ndices em colunas frequentemente usadas em cl√°usulas
              <code>WHERE</code>, <code>JOIN</code>, <code>ORDER BY</code> e <code>GROUP BY</code>. Mas n√£o exagere,
              √≠ndices adicionam overhead em opera√ß√µes DML.
            </li>
            <li><strong>Cuidado com Fun√ß√µes em Cl√°usulas <code>WHERE</code>:</strong> Aplicar fun√ß√µes a colunas
              indexadas em cl√°usulas <code>WHERE</code> pode impedir o uso do √≠ndice (Ex: `WHERE TRUNC(data_coluna) =
              ...`). Tente reescrever a condi√ß√£o para que o √≠ndice possa ser usado (Ex: `WHERE data_coluna >= TRUNC(...)
              AND data_coluna < TRUNC(...) + 1`).</li>
            <li><strong>Preferir <code>JOINs</code> a Subconsultas (quando aplic√°vel):</strong> Embora subconsultas
              sejam poderosas, em muitos casos, um <code>JOIN</code> bem otimizado pode ter um desempenho superior,
              especialmente quando o otimizador pode reescrever a consulta de forma mais eficiente.</li>
            <li><strong>Evite <code>OR</code> em Colunas N√£o Indexadas:</strong> M√∫ltiplas condi√ß√µes com <code>OR</code>
              em colunas n√£o indexadas podem levar a escaneamentos de tabela completos. Considere <code>UNION ALL</code>
              ou indexa√ß√£o.</li>
            <li><strong>Uso Consciente de <code>DISTINCT</code>:</strong> <code>DISTINCT</code> pode ser custoso,
              especialmente em grandes conjuntos de dados, pois exige uma ordena√ß√£o e desduplica√ß√£o. Use-o apenas quando
              necess√°rio.</li>
            <li><strong>Evite `ORDER BY` sem necessidade:</strong> A ordena√ß√£o √© uma opera√ß√£o custosa. Use `ORDER BY`
              apenas quando a ordem dos resultados for estritamente necess√°ria.</li>
            <li><strong>Qualifique Nomes de Objetos:</strong> Use `SCHEMA.TABLE.COLUMN` ou `ALIAS.COLUMN` para evitar
              ambiguidades e melhorar a legibilidade.</li>
          </ul>
        </div>
      </div>

      <div class="sub-section">
        <h2>2Ô∏è‚É£ Otimiza√ß√£o de Consultas com <code>EXPLAIN PLAN</code> <i class="fas fa-microscope"></i></h2>
        <blockquote>
          <p>O <code>EXPLAIN PLAN</code> √© uma ferramenta essencial no Oracle para entender como o banco de dados
            executa uma consulta. Ele mostra o "plano de execu√ß√£o", que √© a sequ√™ncia de opera√ß√µes que o otimizador de
            consultas escolhe para obter os dados.</p>
        </blockquote>
        <div class="card">
          <h3>Como Usar:</h3>
          <p>Voc√™ pode usar a sintaxe <code>EXPLAIN PLAN FOR</code> antes da sua consulta.</p>
          <pre><code class="language-sql">
EXPLAIN PLAN FOR
SELECT A.NOME, N.NOTA
FROM ALUNOS A
JOIN NOTAS N ON A.ID = N.ALUNO_ID
WHERE N.NOTA > 7.0
AND A.CIDADE = 'Recife';

-- Para ver o resultado do plano:
SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY);
          </code></pre>
          <h3>Interpretando o Plano (B√°sico):</h3>
          <ul>
            <li><strong>Operation (Opera√ß√£o):</strong> Descreve a a√ß√£o que o Oracle est√° executando (ex: `TABLE ACCESS
              FULL`, `INDEX UNIQUE SCAN`, `NESTED LOOPS`).</li>
            <li><strong>Object Name (Nome do Objeto):</strong> A tabela, √≠ndice ou view envolvida na opera√ß√£o.</li>
            <li><strong>Rows (Linhas):</strong> Estimativa do n√∫mero de linhas que a opera√ß√£o produzir√° ou processar√°.
            </li>
            <li><strong>Cost (Custo):</strong> Estimativa do custo relativo da opera√ß√£o. Um custo menor geralmente
              indica um plano mais eficiente. O custo total √© a soma dos custos individuais.</li>
            <li><strong>Bytes:</strong> Estimativa do n√∫mero de bytes que a opera√ß√£o produzir√°.</li>
            <li><strong>Id (Identificador):</strong> N√∫mero que identifica a opera√ß√£o no plano.</li>
            <li><strong>Parent_Id (ID Pai):</strong> O ID da opera√ß√£o "pai", indicando a hierarquia.</li>
          </ul>
          <p><strong>Dicas para Interpreta√ß√£o:</strong></p>
          <ul>
            <li>Procure por `TABLE ACCESS FULL` em tabelas grandes; isso pode indicar a falta de um √≠ndice ou um √≠ndice
              n√£o utilizado.</li>
            <li>`INDEX UNIQUE SCAN` e `INDEX RANGE SCAN` geralmente s√£o desej√°veis, indicando o uso eficiente de
              √≠ndices.</li>
            <li>Considere o custo total. Seu objetivo √© reduzir esse valor.</li>
          </ul>
        </div>
      </div>

      <div class="sub-section">
        <h2>3Ô∏è‚É£ Otimiza√ß√£o de Desempenho em PL/SQL <i class="fas fa-tachometer-alt"></i></h2>
        <blockquote>
          <p>No PL/SQL, a performance √© frequentemente impactada pela intera√ß√£o com o SQL. Reduzir o n√∫mero de "context
            switches" (trocas entre o motor PL/SQL e o motor SQL) √© fundamental.</p>
        </blockquote>
        <div class="card">
          <h3>3.1. SQL Tuning dentro do PL/SQL:</h3>
          <p>As boas pr√°ticas de SQL aplicam-se integralmente ao SQL incorporado em blocos PL/SQL. Uma consulta lenta
            dentro de um loop PL/SQL pode degradar drasticamente a performance.</p>
          <h3>3.2. T√©cnicas de Processamento em Massa (Bulk Processing):</h3>
          <p>Para opera√ß√µes com grandes volumes de dados, evite processar uma linha de cada vez (row-by-row processing).
            O Oracle oferece mecanismos para processar dados em "lotes" (batches), minimizando as trocas de contexto.
          </p>
          <ul>
            <li>
              <strong><code>FORALL</code> (para DML):</strong>
              <p>Usado para executar uma instru√ß√£o DML (<code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>)
                para cada elemento em uma cole√ß√£o PL/SQL. √â muito mais r√°pido do que um loop com DMLs individuais.</p>
              <pre><code class="language-sql">
DECLARE
  TYPE tp_ids_alunos IS TABLE OF ALUNOS.ID%TYPE INDEX BY PLS_INTEGER;
  v_ids tp_ids_alunos;
BEGIN
  -- Popula a cole√ß√£o (ex: IDs de alunos a serem atualizados)
  SELECT ID BULK COLLECT INTO v_ids FROM ALUNOS WHERE STATUS_MATRICULA = 'Ativo';

  IF v_ids.COUNT > 0 THEN
    FORALL i IN v_ids.FIRST..v_ids.LAST
      UPDATE ALUNOS
      SET STATUS_MATRICULA = 'Concluido'
      WHERE ID = v_ids(i);
  END IF;
  COMMIT;
EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Erro: ' || SQLERRM);
END;
/
              </code></pre>
            </li>
            <li>
              <strong><code>BULK COLLECT</code> (para <code>SELECT</code>):</strong>
              <p>Usado com a cl√°usula <code>INTO</code> de um <code>SELECT</code> para buscar m√∫ltiplas linhas em uma
                cole√ß√£o PL/SQL de uma s√≥ vez, em vez de uma por uma com um cursor tradicional.</p>
              <pre><code class="language-sql">
DECLARE
  TYPE tp_alunos IS TABLE OF ALUNOS%ROWTYPE;
  v_alunos tp_alunos;
BEGIN
  -- Busca todos os alunos ativos de uma vez
  SELECT * BULK COLLECT INTO v_alunos
  FROM ALUNOS
  WHERE STATUS_MATRICULA = 'Ativo';

  -- Processa a cole√ß√£o em PL/SQL (sem mais trocas de contexto)
  FOR i IN v_alunos.FIRST..v_alunos.LAST LOOP
    DBMS_OUTPUT.PUT_LINE('Aluno: ' || v_alunos(i).NOME || ' - Email: ' || v_alunos(i).EMAIL);
  END LOOP;
END;
/
              </code></pre>
            </li>
          </ul>
        </div>
      </div>

      <div class="sub-section">
        <h2>4Ô∏è‚É£ Gerenciamento de Estat√≠sticas do Otimizador <i class="fas fa-chart-bar"></i></h2>
        <blockquote>
          <p>O otimizador de consultas do Oracle depende muito das <strong>estat√≠sticas</strong> dos objetos do banco de
            dados (tabelas, √≠ndices) para gerar os melhores planos de execu√ß√£o. Estat√≠sticas desatualizadas ou ausentes
            podem levar a planos ineficientes e, consequentemente, a um desempenho ruim.</p>
        </blockquote>
        <div class="card">
          <h3>Por que s√£o Importantes?</h3>
          <p>As estat√≠sticas fornecem ao otimizador informa√ß√µes sobre a distribui√ß√£o dos dados, o n√∫mero de linhas, o
            n√∫mero de blocos, a densidade de colunas, etc. Com base nessas informa√ß√µes, o otimizador pode estimar com
            precis√£o o custo de diferentes planos de execu√ß√£o e escolher o mais eficiente.</p>
          <h3>Como Coletar Estat√≠sticas:</h3>
          <p>O Oracle pode coletar estat√≠sticas automaticamente (via tarefas agendadas), mas voc√™ tamb√©m pode fazer isso
            manualmente, especialmente ap√≥s grandes altera√ß√µes nos dados (cargas em massa, exclus√µes significativas).
          </p>
          <pre><code class="language-sql">
-- Coleta estat√≠sticas para uma tabela e seus √≠ndices
EXEC DBMS_STATS.GATHER_TABLE_STATS(
    ownname => 'SEU_SCHEMA',        -- Substitua pelo nome do seu schema
    tabname => 'SUA_TABELA',        -- Substitua pelo nome da sua tabela
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE, -- Percentual da tabela para amostrar
    degree => DBMS_STATS.DEFAULT_DEGREE, -- Grau de paralelismo
    cascade => TRUE                 -- Coleta estat√≠sticas para √≠ndices e colunas
);

-- Para todo o schema:
EXEC DBMS_STATS.GATHER_SCHEMA_STATS(
    ownname => 'SEU_SCHEMA',
    estimate_percent => DBMS_STATS.AUTO_SAMPLE_SIZE,
    degree => DBMS_STATS.DEFAULT_DEGREE,
    cascade => TRUE
);
          </code></pre>
          <h3>Dicas:</h3>
          <ul>
            <li><strong>Frequ√™ncia:</strong> Garanta que as estat√≠sticas sejam coletadas regularmente, especialmente em
              tabelas com alta taxa de modifica√ß√£o de dados.</li>
            <li><strong>Amostragem:</strong> `DBMS_STATS.AUTO_SAMPLE_SIZE` geralmente √© suficiente, mas em tabelas muito
              grandes e com distribui√ß√£o de dados complexa, uma amostragem maior ou at√© mesmo a coleta completa (`100`)
              pode ser considerada.</li>
            <li><strong>Impacto:</strong> A coleta de estat√≠sticas pode consumir recursos. Agende-a para per√≠odos de
              baixa atividade.</li>
          </ul>
        </div>
      </div>

      <div class="sub-section">
        <h2>5Ô∏è‚É£ Hints (Dicas para o Otimizador) <i class="fas fa-lightbulb"></i></h2>
        <blockquote>
          <p>Hints s√£o coment√°rios especiais que voc√™ pode adicionar √†s suas instru√ß√µes SQL para "sugerir" ao otimizador
            do Oracle como voc√™ gostaria que a consulta fosse executada. Embora o otimizador geralmente fa√ßa um bom
            trabalho por conta pr√≥pria, h√° situa√ß√µes em que voc√™, como desenvolvedor, conhece melhor os dados ou o
            ambiente e pode guiar o otimizador para um plano mais eficiente.</p>
        </blockquote>
        <div class="card">
          <h3>Quando Usar Hints?</h3>
          <ul>
            <li>Quando o otimizador n√£o est√° gerando um plano eficiente, mesmo com estat√≠sticas atualizadas.</li>
            <li>Em ambientes controlados para testar e fixar planos de execu√ß√£o espec√≠ficos.</li>
            <li>Para solucionar problemas de desempenho pontuais.</li>
          </ul>
          <h3>Como Usar:</h3>
          <p>Hints s√£o colocados em coment√°rios ap√≥s a palavra-chave <code>SELECT</code>, <code>INSERT</code>,
            <code>UPDATE</code> ou <code>DELETE</code>, dentro de <code>/*+ ... */</code>.
          </p>
          <pre><code class="language-sql">
-- For√ßar um "Full Table Scan" na tabela ALUNOS
SELECT /*+ FULL(a) */ a.nome, a.data_nascimento
FROM ALUNOS a
WHERE a.status_matricula = 'Ativo';

-- For√ßar o uso de um √≠ndice espec√≠fico para a tabela ALUNOS
SELECT /*+ INDEX(a IDX_ALUNOS_DT_NASC) */ a.nome, a.data_nascimento
FROM ALUNOS a
WHERE a.data_nascimento > TO_DATE('01-JAN-2000', 'DD-MON-YYYY');

-- For√ßar um tipo de JOIN (ex: NESTED LOOPS)
SELECT /*+ USE_NL(e d) */ e.nome, d.nome_departamento
FROM EMPREGADOS e
JOIN DEPARTAMENTOS d ON e.id_departamento = d.id;
          </code></pre>
          <h3>Cuidado!</h3>
          <ul>
            <li><strong>√öltimo Recurso:</strong> Use hints com modera√ß√£o e apenas quando estritamente necess√°rio. O
              otimizador geralmente √© mais inteligente.</li>
            <li><strong>Manuten√ß√£o:</strong> Hints podem se tornar um problema de manuten√ß√£o. Se a distribui√ß√£o dos
              dados ou a estrutura da tabela mudar, um hint que era bom antes pode se tornar prejudicial.</li>
            <li><strong>Teste:</strong> Sempre teste exaustivamente consultas com hints em ambientes de desenvolvimento
              e homologa√ß√£o antes de aplicar em produ√ß√£o.</li>
          </ul>
        </div>
      </div>

      <div class="sub-section">
        <h2>6Ô∏è‚É£ Ferramentas de Profiling em PL/SQL <i class="fas fa-tools"></i></h2>
        <blockquote>
          <p>Al√©m do <code>EXPLAIN PLAN</code> para SQL, o Oracle oferece ferramentas para analisar o desempenho do seu
            c√≥digo PL/SQL, identificando gargalos e partes que consomem mais tempo.</p>
        </blockquote>
        <div class="card">
          <h3><code>DBMS_PROFILER</code></h3>
          <p>Este pacote permite que voc√™ execute seu c√≥digo PL/SQL e colete estat√≠sticas detalhadas sobre o tempo de
            execu√ß√£o de cada linha e unidade de c√≥digo (fun√ß√µes, procedures, pacotes).</p>
          <pre><code class="language-sql">
-- 1. Habilitar o profiler (uma vez por sess√£o)
-- Se as tabelas de profiler n√£o existirem, voc√™ precisar√° cri√°-las primeiro
-- @?/rdbms/admin/profload.sql
EXEC DBMS_PROFILER.START_PROFILER('Nome da Execucao');

-- 2. Execute seu bloco PL/SQL, procedure ou fun√ß√£o aqui
BEGIN
  -- Seu c√≥digo PL/SQL a ser perfilado
  FOR i IN 1..100000 LOOP
    INSERT INTO minha_tabela (col1) VALUES (i);
  END LOOP;
  COMMIT;
END;
/

-- 3. Parar o profiler
EXEC DBMS_PROFILER.STOP_PROFILER;

-- 4. Analisar os resultados (usando tabelas do profiler)
-- Exemplo de consulta para ver as unidades que mais consumiram tempo
SELECT
    u.unit_name,
    s.total_time,
    s.total_occurrences,
    s.total_lines
FROM
    plsql_profiler_runs r
JOIN
    plsql_profiler_units u ON r.runid = u.runid
JOIN
    plsql_profiler_data s ON u.runid = s.runid AND u.unit_number = s.unit_number
WHERE
    r.run_comment = 'Nome da Execucao'
ORDER BY
    s.total_time DESC;
          </code></pre>
          <h3><code>DBMS_HPROF</code> (Hierarchical Profiler)</h3>
          <p><code>DBMS_HPROF</code> √© uma ferramenta mais moderna e poderosa que fornece uma vis√£o hier√°rquica do tempo
            de execu√ß√£o, permitindo ver chamadas de subprogramas e o tempo gasto em cada n√≠vel da pilha de chamadas. Ele
            gera um arquivo de trace que pode ser analisado com a ferramenta <code>tkprof</code>.</p>
          <pre><code class="language-sql">
-- 1. Habilitar o HProf
-- Define o diret√≥rio onde o arquivo de trace ser√° gerado (precisa ser um diret√≥rio do Oracle)
CREATE DIRECTORY HPROF_DIR AS '/tmp'; -- Crie este diret√≥rio no servidor Oracle, se n√£o existir

DECLARE
    v_run_id NUMBER;
BEGIN
    v_run_id := DBMS_HPROF.START_PROFILING(
        location => 'HPROF_DIR',
        filename => 'my_plsql_profile.trc'
    );

    -- 2. Execute seu bloco PL/SQL, procedure ou fun√ß√£o aqui
    FOR i IN 1..100000 LOOP
        INSERT INTO minha_tabela (col1) VALUES (i);
    END LOOP;
    COMMIT;

    DBMS_HPROF.STOP_PROFILING(v_run_id);
END;
/
          </code></pre>
          <p>Ap√≥s a execu√ß√£o, voc√™ precisar√° usar a ferramenta de linha de comando `tkprof` no servidor para formatar o
            arquivo `.trc` em um relat√≥rio leg√≠vel.</p>
        </div>
      </div>

      <div class="exercise">
        <h2>Exerc√≠cios e Desafios <i class="fas fa-question-circle"></i></h2>
        <p>Para solidificar seu aprendizado, tente resolver os seguintes desafios:</p>
        <div class="card">
          <ol>
            <li>
              Imagine uma consulta que busca todos os alunos que nasceram ap√≥s 1¬∫ de janeiro de 2000 e t√™m "Silva" no
              nome. Escreva essa consulta e, em seguida, use o `EXPLAIN PLAN` para ver seu plano de execu√ß√£o. Baseado no
              plano, que sugest√µes de otimiza√ß√£o voc√™ daria (pensando em √≠ndices, se aplic√°vel)?
              <button onclick="toggleAnswer('ansEx1')">Mostrar Gabarito</button>
              <div class="answer" id="ansEx1">
                <pre><code class="language-sql">
-- Consulta
SELECT ID, NOME, DATA_NASCIMENTO
FROM ALUNOS
WHERE DATA_NASCIMENTO > TO_DATE('01-JAN-2000', 'DD-MON-YYYY')
AND NOME LIKE '%Silva%';

-- Para ver o plano de execu√ß√£o:
EXPLAIN PLAN FOR
SELECT ID, NOME, DATA_NASCIMENTO
FROM ALUNOS
WHERE DATA_NASCIMENTO > TO_DATE('01-JAN-2000', 'DD-MON-YYYY')
AND NOME LIKE '%Silva%';

SELECT PLAN_TABLE_OUTPUT FROM TABLE(DBMS_XPLAN.DISPLAY);

-- Sugest√µes de Otimiza√ß√£o (Baseadas em um plano comum):
-- 1. Se a coluna DATA_NASCIMENTO for frequentemente usada em WHERE, considere criar um √≠ndice nela:
--    CREATE INDEX IDX_ALUNOS_DT_NASC ON ALUNOS (DATA_NASCIMENTO);
-- 2. A condi√ß√£o `LIKE '%Silva%'` impede o uso de um √≠ndice na coluna NOME para o in√≠cio da string (range scan).
--    Se o filtro principal for por sobrenome, e 'Silva' for comum no meio/fim, um √≠ndice na coluna NOME ainda pode ser √∫til
--    se a query for combinada com outros filtros mais seletivos ou se o otimizador decidir usar.
--    Para `LIKE '%valor%'`, a Oracle precisaria de um INDEX FULL SCAN ou FULL TABLE SCAN (se n√£o houver outros √≠ndices).
--    Em alguns casos, √≠ndices baseados em fun√ß√µes ou Oracle Text Search podem ser considerados para pesquisas de texto mais complexas.
-- 3. Certifique-se de que a tabela ALUNOS n√£o √© muito pequena, pois para tabelas pequenas, um TABLE ACCESS FULL pode ser mais r√°pido do que usar um √≠ndice.
                </code></pre>
              </div>
            </li>
            <li>
              Crie um bloco PL/SQL que atualize o `STATUS_MATRICULA` de todos os alunos da tabela `ALUNOS` de 'Ativo'
              para 'Concluido' para aqueles que t√™m uma nota m√©dia superior a 7.0 em todas as suas disciplinas. Use
              `BULK COLLECT` para buscar os IDs dos alunos e `FORALL` para realizar a atualiza√ß√£o.
              <button onclick="toggleAnswer('ansEx2')">Mostrar Gabarito</button>
              <div class="answer" id="ansEx2">
                <pre><code class="language-sql">
DECLARE
  TYPE tp_aluno_id IS TABLE OF ALUNOS.ID%TYPE;
  v_alunos_para_atualizar tp_aluno_id;
BEGIN
  -- 1. Usar BULK COLLECT para obter os IDs dos alunos que se encaixam no crit√©rio
  SELECT A.ID BULK COLLECT INTO v_alunos_para_atualizar
  FROM ALUNOS A
  WHERE A.STATUS_MATRICULA = 'Ativo'
  AND (SELECT AVG(N.NOTA)
        FROM NOTAS N
        WHERE N.ALUNO_ID = A.ID) > 7.0;

  -- 2. Usar FORALL para atualizar em massa
  IF v_alunos_para_atualizar.COUNT > 0 THEN
    FORALL i IN v_alunos_para_atualizar.FIRST..v_alunos_para_atualizar.LAST
      UPDATE ALUNOS
      SET STATUS_MATRICULA = 'Concluido'
      WHERE ID = v_alunos_para_atualizar(i);
    COMMIT;
    DBMS_OUTPUT.PUT_LINE(v_alunos_para_atualizar.COUNT || ' alunos atualizados para "Concluido".');
  ELSE
    DBMS_OUTPUT.PUT_LINE('Nenhum aluno encontrado para atualiza√ß√£o.');
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    ROLLBACK;
    DBMS_OUTPUT.PUT_LINE('Ocorreu um erro: ' || SQLERRM);
END;
/
                </code></pre>
              </div>
            </li>
            <li>
              Explique brevemente a vantagem de usar `FORALL` e `BULK COLLECT` em PL/SQL para opera√ß√µes com muitos
              dados, em compara√ß√£o com o processamento linha a linha (looping com um `SELECT INTO` ou DMLs individuais).
              <button onclick="toggleAnswer('ansEx3')">Mostrar Gabarito</button>
              <div class="answer" id="ansEx3">
                <p>A principal vantagem de `FORALL` e `BULK COLLECT` √© a **redu√ß√£o do n√∫mero de trocas de contexto
                  (context switches)** entre o motor PL/SQL e o motor SQL. Cada vez que o PL/SQL precisa interagir com o
                  SQL (para buscar uma linha, inserir uma linha, etc.), ocorre uma troca de contexto que consome
                  recursos e tempo.</p>
                <ul>
                  <li>Com o **processamento linha a linha**, se voc√™ tem 1000 registros para processar, o PL/SQL far√°
                    1000 chamadas separadas ao motor SQL.</li>
                  <li>Com **`BULK COLLECT`**, o PL/SQL busca *todos* (ou um lote definido de) os 1000 registros em *uma
                    √∫nica* chamada ao motor SQL, preenchendo uma cole√ß√£o. O processamento subsequente dessa cole√ß√£o
                    ocorre inteiramente no motor PL/SQL, sem novas trocas de contexto para cada linha.</li>
                  <li>Com **`FORALL`**, da mesma forma, o PL/SQL envia *todos* (ou um lote definido de) os 1000 comandos
                    DML para o motor SQL em *uma √∫nica* chamada. O motor SQL ent√£o executa esses comandos em massa, de
                    forma muito mais eficiente.</li>
                </ul>
                <p>Isso resulta em uma **melhora significativa no desempenho** para opera√ß√µes com grandes volumes de
                  dados, pois reduz o overhead de comunica√ß√£o entre os dois motores.</p>
              </div>
            </li>
          </ol>
        </div>
      </div>

    </div>

  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {

      const hamburgerMenu = document.getElementById('hamburger-menu');
      const sidebar = document.getElementById('sidebar');
      const content = document.getElementById('content');
      const overlay = document.getElementById('overlay');
      const sidebarLinks = sidebar.querySelectorAll('a');

      function toggleSidebar() {
        sidebar.classList.toggle('active');
        content.classList.toggle('sidebar-active');
        overlay.classList.toggle('active');
      }

      // Adiciona event listeners AP√ìS os elementos serem garantidamente carregados no DOM
      if (hamburgerMenu) {
        hamburgerMenu.addEventListener('click', toggleSidebar);
      } else {
        console.warn('Elemento #hamburger-menu n√£o encontrado. Verifique o HTML.');
      }

      if (overlay) {
        overlay.addEventListener('click', toggleSidebar);
      } else {
        console.warn('Elemento #overlay n√£o encontrado. Verifique o HTML.');
      }


      sidebarLinks.forEach(link => {
        link.addEventListener('click', function () {
          if (sidebar.classList.contains('active')) {
            toggleSidebar();
          }
        });
      });

      function highlightActiveLink() {
        const currentPathname = window.location.pathname;
        let currentFileName = currentPathname.split('/').pop();

        // Se a URL termina em '/', o arquivo atual √© 'index.html'
        if (currentFileName === '' || currentFileName === 'aulas_sql') { // Adicionado 'aulas_sql' caso a URL base seja s√≥ o nome do repo
          currentFileName = 'index.html';
        }

        sidebarLinks.forEach(link => {
          const linkHref = link.getAttribute('href');

          link.classList.remove('active'); // Remove de todos primeiro

          // L√≥gica para marcar o link ativo
          if (linkHref === currentFileName || (currentFileName === 'index.html' && linkHref === 'index.html')) {
            link.classList.add('active');
          }
        });
      }

      highlightActiveLink(); // Chama a fun√ß√£o ao inicializar a sidebar

      // Fun√ß√£o para mostrar/esconder o gabarito
      window.toggleAnswer = function (id) {
        var x = document.getElementById(id);
        if (x.style.display === "none" || x.style.display === "") {
          x.style.display = "block";
        } else {
          x.style.display = "none";
        }
      };
    });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
</body>

</html>