<!DOCTYPE html>
<html lang="pt-br">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Programa√ß√£o no Banco de Dados (Objetos Program√°ticos) - PL/SQL</title>
  <link rel="stylesheet" href="styles.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
</head>

<body>
  <div class="overlay" id="overlay"></div>

  <button class="hamburger-menu" id="hamburger-menu">
    <i class="fas fa-bars"></i>
  </button>

  <div class="sidebar" id="sidebar">
    <h2>PL/SQL üöÄ</h2>
    <a href="index.html"><i class="fas fa-home"></i> <span>In√≠cio</span></a>
    <a href="Conceitos BD.html"><i class="fas fa-book"></i> <span>Conceitos
        BD</span></a>
    <a href="SQL Essencial.html"><i class="fas fa-code"></i> <span>SQL Essencial</span></a>
    <a href="SQL - Fundamentos Avan√ßados.html"><i class="fas fa-database"></i> <span>SQL Fundamentos
        Avan√ßados</span></a>
    <a href="SQL - Agregacao e Subconsultas.html"><i class="fas fa-calculator"></i> <span>Agrega√ß√£o e
        Subconsultas</span></a>
    <a href="SQL - DDL Avancado e objetos.html"><i class="fas fa-cogs"></i> <span>SQL DDL Avan√ßado</span></a>
    <a href="Pr√°tica e Otimiza√ß√£o.html"><i class="fas fa-chart-line"></i> <span>Pr√°tica e Otimiza√ß√£o</span></a>
    <a href="PLSQL - Fundamentos e Estruturas de Controle.html"><i class="fas fa-file-code"></i> <span>PL/SQL
        Fundamentos</span></a>
    <a href="SQL Programacao.html"><i class="fas fa-cogs"></i><span>PL/SQL Programa√ß√£o</span></a>
    <a href="PLSQL - Tratamento de Excecoes e Pacotes.html"><i class="fas fa-boxes"></i> <span>PL/SQL Exce√ß√µes e
        Pacotes</span></a>
    <a href="Extras - PL_SQL Avan√ßado.html"><i class="fas fa-plus-circle"></i> <span>PL/SQL Avan√ßado</span></a>
  </div>

  <div class="content" id="content">
    <header>
      <h1>Programa√ß√£o no Banco de Dados (Objetos Program√°ticos)</h1>
      <p>Aprenda a criar objetos program√°ticos para estender a l√≥gica de neg√≥cio diretamente no Oracle Database.</p>
    </header>

    <div class="main-section">

      <div class="sub-section">
        <h2>1Ô∏è‚É£ Exibindo Sa√≠da e Tratando Erros: <code>DBMS_OUTPUT.PUT_LINE</code> e
          <code>RAISE_APPLICATION_ERROR</code> <i class="fas fa-terminal"></i>
        </h2>
        <blockquote>
          <p>Ao programar em PL/SQL, √© essencial ter ferramentas para exibir mensagens, depurar o c√≥digo e lidar com
            situa√ß√µes de erro. O Oracle fornece pacotes e comandos para isso.</p>
        </blockquote>
        <div class="card">
          <h3>1.1. <code>DBMS_OUTPUT.PUT_LINE</code>: Exibindo Mensagens no Console</h3>
          <p>O pacote <code>DBMS_OUTPUT</code> (Database Management System Output) √© uma ferramenta utilit√°ria no Oracle
            Database que permite exibir informa√ß√µes textuais diretamente no console ou em uma interface de
            desenvolvimento (como SQL Developer, SQL*Plus, DBeaver) durante a execu√ß√£o de blocos PL/SQL, procedures,
            functions ou triggers. A fun√ß√£o <code>PUT_LINE</code> √© a mais comum e envia uma linha de texto para o
            buffer de sa√≠da.</p>

          <h4>Como Habilitar a Sa√≠da:</h4>
          <p>Antes de usar <code>DBMS_OUTPUT.PUT_LINE</code>, voc√™ precisa habilitar o buffer de sa√≠da no seu ambiente
            de SQL. No SQL*Plus ou SQL Developer, use o seguinte comando:</p>
          <pre><code class="language-sql">
SET SERVEROUTPUT ON;
          </code></pre>
          <p>Este comando habilita a exibi√ß√£o do buffer do `DBMS_OUTPUT` ap√≥s a execu√ß√£o de um bloco PL/SQL. Voc√™ pode
            especificar o tamanho do buffer, como `SET SERVEROUTPUT ON SIZE 1000000;` para um buffer maior.</p>

          <h4>Sintaxe e Uso:</h4>
          <pre><code class="language-sql">
DBMS_OUTPUT.PUT_LINE('Sua mensagem aqui');
          </code></pre>
          <p>Voc√™ pode concatenar strings e vari√°veis usando o operador `||`:</p>
          <pre><code class="language-sql">
DECLARE
  v_nome VARCHAR2(50) := 'Alice';
  v_idade NUMBER := 30;
BEGIN
  DBMS_OUTPUT.PUT_LINE('Ol√°, ' || v_nome || '! Voc√™ tem ' || v_idade || ' anos.');
END;
/
          </code></pre>

          <h4>Exemplos Pr√°ticos:</h4>
          <h5>Exemplo 1: Exibindo o resultado de um c√°lculo</h5>
          <pre><code class="language-sql">
SET SERVEROUTPUT ON;
DECLARE
  v_num1 NUMBER := 10;
  v_num2 NUMBER := 5;
  v_soma NUMBER;
BEGIN
  v_soma := v_num1 + v_num2;
  DBMS_OUTPUT.PUT_LINE('A soma de ' || v_num1 || ' e ' || v_num2 || ' √©: ' || v_soma);
END;
/
          </code></pre>
          <h5>Exemplo 2: Usando para depura√ß√£o em um bloco an√¥nimo</h5>
          <pre><code class="language-sql">
SET SERVEROUTPUT ON;
DECLARE
  v_salario NUMBER := 5000;
  v_bonus NUMBER := 1000;
  v_salario_total NUMBER;
BEGIN
  v_salario_total := v_salario + v_bonus;
  DBMS_OUTPUT.PUT_LINE('DEBUG: Sal√°rio base: ' || v_salario);
  DBMS_OUTPUT.PUT_LINE('DEBUG: B√¥nus: ' || v_bonus);
  DBMS_OUTPUT.PUT_LINE('Sal√°rio total: ' || v_salario_total);
END;
/
          </code></pre>
          <p><code>DBMS_OUTPUT.PUT_LINE</code> √© uma ferramenta valiosa para depura√ß√£o e para fornecer feedback sobre o
            que um bloco PL/SQL est√° fazendo, mas n√£o deve ser usado como o principal m√©todo de comunica√ß√£o com a
            interface do usu√°rio final em aplica√ß√µes complexas.</p>

          <h3>1.2. <code>RAISE_APPLICATION_ERROR</code>: Levantando Erros Personalizados</h3>
          <p>Enquanto <code>DBMS_OUTPUT.PUT_LINE</code> √© para exibir mensagens informativas ou de depura√ß√£o,
            <code>RAISE_APPLICATION_ERROR</code> √© usado para levantar (ou "disparar") um erro customizado que pode ser
            capturado por um bloco <code>EXCEPTION</code> ou que interromper√° a execu√ß√£o do c√≥digo se n√£o for tratado. √â
            a forma padr√£o de sinalizar uma condi√ß√£o de erro que deve ser tratada pela aplica√ß√£o chamadora ou que impede
            a continua√ß√£o de uma opera√ß√£o.
          </p>
          <h4>Sintaxe:</h4>
          <pre><code class="language-sql">
RAISE_APPLICATION_ERROR(erro_numero, mensagem_erro);
          </code></pre>
          <ul>
            <li>`erro_numero`: Um n√∫mero negativo entre -20000 e -20999.</li>
            <li>`mensagem_erro`: Uma string de at√© 2048 caracteres com a descri√ß√£o do erro.</li>
          </ul>
          <h4>Exemplo: Impedindo uma opera√ß√£o com erro</h4>
          <pre><code class="language-sql">
SET SERVEROUTPUT ON;
DECLARE
  v_saldo NUMBER := 100;
  v_valor_saque NUMBER := 150;
BEGIN
  IF v_valor_saque > v_saldo THEN
    DBMS_OUTPUT.PUT_LINE('Erro: Saldo insuficiente para o saque de ' || v_valor_saque || '. Saldo atual: ' || v_saldo);
    RAISE_APPLICATION_ERROR(-20001, 'Saldo insuficiente. Saque cancelado.');
  ELSE
    v_saldo := v_saldo - v_valor_saque;
    DBMS_OUTPUT.PUT_LINE('Saque de ' || v_valor_saque || ' realizado com sucesso. Novo saldo: ' || v_saldo);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Ocorreu um erro tratado: ' || SQLERRM);
END;
/
          </code></pre>
          <p>A combina√ß√£o de `DBMS_OUTPUT.PUT_LINE` para depura√ß√£o e `RAISE_APPLICATION_ERROR` para controle de fluxo de
            erro √© fundamental em PL/SQL.</p>
        </div>
      </div>

      <div class="sub-section">
        <h2>2Ô∏è‚É£ Procedures (Procedimentos) <i class="fas fa-gears"></i></h2>
        <blockquote>
          <p>Procedures s√£o blocos de c√≥digo PL/SQL nomeados e armazenados no banco de dados. Eles executam uma a√ß√£o
            espec√≠fica e podem aceitar par√¢metros de entrada e sa√≠da. N√£o retornam um valor diretamente, mas podem
            modificar par√¢metros <code>OUT</code>.</p>
        </blockquote>
        <div class="card">
          <h3>Sintaxe B√°sica:</h3>
          <pre><code class="language-sql">
CREATE [OR REPLACE] PROCEDURE nome_procedimento (
  parametro1 IN TIPO_DADO,
  parametro2 OUT TIPO_DADO,
  parametro3 IN OUT TIPO_DADO
)
IS
  -- Declara√ß√µes de vari√°veis locais
BEGIN
  -- L√≥gica do procedimento
EXCEPTION
  -- Tratamento de exce√ß√µes
END;
/
          </code></pre>
          <h3>Modos de Par√¢metros:</h3>
          <ul>
            <li><code>IN</code> (Padr√£o): O par√¢metro √© somente leitura dentro do procedimento. Usado para passar
              valores de entrada.</li>
            <li><code>OUT</code>: O par√¢metro √© somente grava√ß√£o dentro do procedimento. Qualquer valor atribu√≠do a ele
              no procedimento ser√° retornado para o chamador. O valor inicial √© sempre NULL.</li>
            <li><code>IN OUT</code>: O par√¢metro pode ser lido e gravado dentro do procedimento. O valor inicial √©
              passado para o procedimento, e qualquer altera√ß√£o √© retornada para o chamador.</li>
          </ul>
          <h3>Exemplo Pr√°tico:</h3>
          <p>Cria√ß√£o de uma procedure para atualizar o email de um aluno e retornar o nome antigo.</p>
          <pre><code class="language-sql">
-- Cria√ß√£o da Procedure
CREATE OR REPLACE PROCEDURE ATUALIZAR_EMAIL_ALUNO (
  p_aluno_id IN ALUNOS.ID%TYPE,
  p_novo_email IN ALUNOS.EMAIL%TYPE,
  p_nome_antigo OUT ALUNOS.NOME%TYPE -- Retorna o nome do aluno antes da atualiza√ß√£o
)
IS
  v_nome_temp ALUNOS.NOME%TYPE;
BEGIN
  -- Obter o nome antigo antes de atualizar
  SELECT NOME INTO v_nome_temp
  FROM ALUNOS
  WHERE ID = p_aluno_id;

  -- Atualizar o email
  UPDATE ALUNOS
  SET EMAIL = p_novo_email
  WHERE ID = p_aluno_id;

  -- Atribuir o nome antigo ao par√¢metro OUT
  p_nome_antigo := v_nome_temp;

  COMMIT; -- Confirma a transa√ß√£o
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    DBMS_OUTPUT.PUT_LINE('Aluno com ID ' || p_aluno_id || ' n√£o encontrado.');
    ROLLBACK;
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Erro ao atualizar email: ' || SQLERRM);
    ROLLBACK;
END;
/

-- Como chamar a Procedure
SET SERVEROUTPUT ON;
DECLARE
  v_nome_antigo_do_aluno ALUNOS.NOME%TYPE;
BEGIN
  ATUALIZAR_EMAIL_ALUNO(1, 'joao.novo@email.com', v_nome_antigo_do_aluno);
  DBMS_OUTPUT.PUT_LINE('O nome antigo do aluno era: ' || v_nome_antigo_do_aluno);
END;
/
          </code></pre>
        </div>
      </div>

      <div class="sub-section">
        <h2>3Ô∏è‚É£ Functions (Fun√ß√µes) <i class="fas fa-calculator-alt"></i></h2>
        <blockquote>
          <p>Fun√ß√µes s√£o blocos de c√≥digo PL/SQL nomeados e armazenados no banco de dados, semelhantes a procedures, mas
            com uma diferen√ßa fundamental: **uma fun√ß√£o DEVE retornar um valor**. S√£o frequentemente usadas para
            c√°lculos e podem ser chamadas em express√µes SQL.</p>
        </blockquote>
        <div class="card">
          <h3>Sintaxe B√°sica:</h3>
          <pre><code class="language-sql">
CREATE [OR REPLACE] FUNCTION nome_funcao (
  parametro1 IN TIPO_DADO,
  parametro2 IN TIPO_DADO DEFAULT valor_padrao -- Par√¢metros de fun√ß√£o s√£o sempre IN
)
RETURN TIPO_DE_RETORNO
IS
  -- Declara√ß√µes de vari√°veis locais
BEGIN
  -- L√≥gica da fun√ß√£o
  RETURN valor_a_retornar;
EXCEPTION
  -- Tratamento de exce√ß√µes
END;
/
          </code></pre>
          <h3>Retornando M√∫ltiplos Valores de uma Fun√ß√£o (Abordagens):</h3>
          <p>Uma fun√ß√£o PL/SQL, por defini√ß√£o, pode retornar apenas um √∫nico valor atrav√©s da cl√°usula `RETURN`. No
            entanto, existem maneiras de "simular" o retorno de m√∫ltiplos valores, que s√£o mais apropriadas para
            procedures ou para retorno de tipos complexos:</p>
          <h4>3.1. Usando Par√¢metros <code>OUT</code> (Comum em Procedures, Poss√≠vel em Functions)</h4>
          <p>Embora mais comum em procedures, uma fun√ß√£o pode ter par√¢metros <code>OUT</code> al√©m do seu valor de
            retorno prim√°rio. Isso n√£o √© uma pr√°tica muito comum para "fun√ß√µes puras", que idealmente n√£o teriam efeitos
            colaterais (como modificar par√¢metros OUT), mas √© tecnicamente poss√≠vel.</p>
          <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION GET_ALUNO_INFO (
  p_aluno_id IN ALUNOS.ID%TYPE,
  p_nome OUT ALUNOS.NOME%TYPE,
  p_email OUT ALUNOS.EMAIL%TYPE
)
RETURN NUMBER -- Retorna o ID do aluno, por exemplo, ou um status code
IS
BEGIN
  SELECT NOME, EMAIL
  INTO p_nome, p_email
  FROM ALUNOS
  WHERE ID = p_aluno_id;

  RETURN p_aluno_id; -- Retorno principal da fun√ß√£o
EXCEPTION
  WHEN NO_DATA_FOUND THEN
    p_nome := NULL;
    p_email := NULL;
    RETURN -1; -- Indicador de erro ou n√£o encontrado
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Erro na fun√ß√£o GET_ALUNO_INFO: ' || SQLERRM);
    p_nome := NULL;
    p_email := NULL;
    RETURN -2; -- Indicador de erro gen√©rico
END;
/

-- Como chamar e consumir os m√∫ltiplos valores
SET SERVEROUTPUT ON;
DECLARE
  v_nome_aluno ALUNOS.NOME%TYPE;
  v_email_aluno ALUNOS.EMAIL%TYPE;
  v_id_retornado NUMBER;
BEGIN
  -- Assumindo que ALUNOS √© (ID NUMBER PRIMARY KEY, NOME VARCHAR2(100), EMAIL VARCHAR2(100))
  -- INSERT INTO ALUNOS (ID, NOME, EMAIL) VALUES (1, 'Jo√£o Silva', 'joao.silva@example.com');
  -- COMMIT;

  v_id_retornado := GET_ALUNO_INFO(1, v_nome_aluno, v_email_aluno);

  IF v_id_retornado != -1 THEN
    DBMS_OUTPUT.PUT_LINE('ID Retornado: ' || v_id_retornado);
    DBMS_OUTPUT.PUT_LINE('Nome do Aluno: ' || v_nome_aluno);
    DBMS_OUTPUT.PUT_LINE('Email do Aluno: ' || v_email_aluno);
  ELSE
    DBMS_OUTPUT.PUT_LINE('Aluno n√£o encontrado!');
  END IF;

END;
/
          </code></pre>

          <h4>3.2. Retornando Tipos Compostos (Records ou Collections)</h4>
          <p>Para um retorno mais estruturado, uma fun√ß√£o pode retornar um tipo composto (como um `RECORD` definido pelo
            usu√°rio ou uma `COLLECTION` / `TABLE OF`). Esta √© a abordagem mais "limpa" para retornar m√∫ltiplos valores
            de uma *fun√ß√£o* em PL/SQL.</p>
          <pre><code class="language-sql">
-- Primeiro, defina um tipo RECORD
CREATE OR REPLACE PACKAGE types_pkg IS
  TYPE t_aluno_record IS RECORD (
    id ALUNOS.ID%TYPE,
    nome ALUNOS.NOME%TYPE,
    email ALUNOS.EMAIL%TYPE
  );
END types_pkg;
/

-- Agora, crie a fun√ß√£o que retorna este RECORD
CREATE OR REPLACE FUNCTION GET_ALUNO_COMPLETO (
  p_aluno_id IN ALUNOS.ID%TYPE
)
RETURN types_pkg.t_aluno_record
IS
  v_aluno_info types_pkg.t_aluno_record;
BEGIN
  SELECT ID, NOME, EMAIL
  INTO v_aluno_info.id, v_aluno_info.nome, v_aluno_info.email
  FROM ALUNOS
  WHERE ID = p_aluno_id;

  RETURN v_aluno_info;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    -- Retorna um record vazio ou com valores padr√£o, ou levanta uma exce√ß√£o
    DBMS_OUTPUT.PUT_LINE('Aluno com ID ' || p_aluno_id || ' n√£o encontrado.');
    RETURN NULL; -- Ou inicialize v_aluno_info com NULLs e retorne
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Erro ao obter informa√ß√µes do aluno: ' || SQLERRM);
    RETURN NULL;
END;
/

-- Como chamar e consumir um record retornado por uma fun√ß√£o
SET SERVEROUTPUT ON;
DECLARE
  v_dados_aluno types_pkg.t_aluno_record;
BEGIN
  -- Supondo que ALUNOS seja (ID NUMBER PRIMARY KEY, NOME VARCHAR2(100), EMAIL VARCHAR2(100))
  -- INSERT INTO ALUNOS (ID, NOME, EMAIL) VALUES (1, 'Jo√£o Silva', 'joao.silva@example.com');
  -- COMMIT;

  v_dados_aluno := GET_ALUNO_COMPLETO(1);

  IF v_dados_aluno.id IS NOT NULL THEN
    DBMS_OUTPUT.PUT_LINE('ID: ' || v_dados_aluno.id);
    DBMS_OUTPUT.PUT_LINE('Nome: ' || v_dados_aluno.nome);
    DBMS_OUTPUT.PUT_LINE('Email: ' || v_dados_aluno.email);
  ELSE
    DBMS_OUTPUT.PUT_LINE('N√£o foi poss√≠vel obter os dados do aluno.');
  END IF;
END;
/
          </code></pre>

          <h3>Exemplo Pr√°tico (Fun√ß√£o com retorno √∫nico):</h3>
          <p>Cria√ß√£o de uma fun√ß√£o para calcular a m√©dia de notas de um aluno.</p>
          <pre><code class="language-sql">
-- Cria√ß√£o da Function
CREATE OR REPLACE FUNCTION GET_MEDIA_ALUNO (
  p_aluno_id IN ALUNOS.ID%TYPE
)
RETURN NUMBER -- A fun√ß√£o retorna um n√∫mero (m√©dia)
IS
  v_media NUMBER := 0;
BEGIN
  SELECT AVG(NOTA) INTO v_media
  FROM NOTAS
  WHERE ALUNO_ID = p_aluno_id;

  -- Se n√£o houver notas, a m√©dia pode ser NULL ou 0, dependendo da regra de neg√≥cio
  IF v_media IS NULL THEN
    RETURN 0; -- Ou levante uma exce√ß√£o, ou retorne NULL
  ELSE
    RETURN v_media;
  END IF;

EXCEPTION
  WHEN NO_DATA_FOUND THEN
    RETURN 0; -- Aluno n√£o existe, ou n√£o tem notas.
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Erro ao calcular m√©dia: ' || SQLERRM);
    RETURN NULL; -- Ou levante a exce√ß√£o novamente
END;
/

-- Como chamar a Function em um bloco PL/SQL
SET SERVEROUTPUT ON;
DECLARE
  v_media_joao NUMBER;
BEGIN
  v_media_joao := GET_MEDIA_ALUNO(1); -- Supondo ID 1 para Jo√£o
  DBMS_OUTPUT.PUT_LINE('M√©dia de notas de Jo√£o: ' || v_media_joao);
END;
/

-- Como chamar a Function em uma query SQL
SELECT NOME, GET_MEDIA_ALUNO(ID) AS MediaNotas
FROM ALUNOS
WHERE STATUS_MATRICULA = 'Ativo';
          </code></pre>
        </div>
      </div>

      <div class="sub-section">
        <h2>4Ô∏è‚É£ Triggers (Gatilhos) <i class="fas fa-bolt"></i></h2>
        <blockquote>
          <p>Triggers s√£o blocos de c√≥digo PL/SQL ou SQL associados a uma tabela, view, schema ou banco de dados que s√£o
            executados automaticamente quando um evento espec√≠fico ocorre (ex: <code>INSERT</code>, <code>UPDATE</code>,
            <code>DELETE</code>, logon, logoff, etc.).
          </p>
        </blockquote>
        <div class="card">
          <h3>Sintaxe B√°sica:</h3>
          <pre><code class="language-sql">
CREATE [OR REPLACE] TRIGGER nome_trigger
{BEFORE | AFTER | INSTEAD OF}
{INSERT | UPDATE [OF coluna1, coluna2] | DELETE}
ON nome_tabela_ou_view
[FOR EACH ROW] -- Opcional: Para triggers de n√≠vel de linha
[WHEN (condicao)] -- Opcional: Condi√ß√£o adicional para disparo
DECLARE
  -- Declara√ß√µes locais (para triggers de n√≠vel de linha)
BEGIN
  -- L√≥gica do trigger
  -- Vari√°veis especiais: :OLD.coluna e :NEW.coluna (para triggers de n√≠vel de linha)
EXCEPTION
  -- Tratamento de exce√ß√µes
END;
/
          </code></pre>
          <h3>Tipos Comuns de Triggers:</h3>
          <ul>
            <li><strong>Timing:</strong> `BEFORE` (antes da opera√ß√£o DML) ou `AFTER` (depois da opera√ß√£o DML).</li>
            <li><strong>Event:</strong> `INSERT`, `UPDATE`, `DELETE`. Voc√™ pode combinar m√∫ltiplos eventos (`INSERT OR
              UPDATE OR DELETE`).</li>
            <li><strong>Level:</strong>
              <ul>
                <li>`FOR EACH ROW` (Trigger de N√≠vel de Linha): Dispara uma vez para cada linha afetada pela opera√ß√£o
                  DML. Voc√™ pode acessar os valores antigos (`:OLD`) e novos (`:NEW`) das colunas.</li>
                <li>(Sem `FOR EACH ROW`) (Trigger de N√≠vel de Instru√ß√£o): Dispara uma vez por instru√ß√£o DML,
                  independentemente do n√∫mero de linhas afetadas. N√£o tem acesso a `:OLD` ou `:NEW`.</li>
              </ul>
            </li>
            <li><strong>`INSTEAD OF` Trigger:</strong> Usado em views complexas (que n√£o s√£o diretamente atualiz√°veis)
              para definir como as opera√ß√µes DML na view devem ser traduzidas para as tabelas base.</li>
          </ul>
          <h3>Vari√°veis Especiais (`:OLD` e `:NEW`):</h3>
          <ul>
            <li>Dispon√≠veis apenas em triggers `FOR EACH ROW`.</li>
            <li>`:OLD.coluna`: Refere-se ao valor da coluna ANTES da opera√ß√£o DML.</li>
            <li>`:NEW.coluna`: Refere-se ao valor da coluna DEPOIS da opera√ß√£o DML.</li>
          </ul>
          <h3>Exemplo Pr√°tico:</h3>
          <p>Cria√ß√£o de um trigger que impede a exclus√£o de um aluno se ele ainda estiver com `STATUS_MATRICULA =
            'Ativo'`.</p>
          <pre><code class="language-sql">
-- Cria√ß√£o do Trigger
CREATE OR REPLACE TRIGGER TRG_IMPEDIR_EXCLUSAO_ALUNO
BEFORE DELETE ON ALUNOS
FOR EACH ROW
BEGIN
  -- Verifica se o status de matr√≠cula √© 'Ativo'
  IF :OLD.STATUS_MATRICULA = 'Ativo' THEN
    -- Se for ativo, levanta uma exce√ß√£o (erro)
    RAISE_APPLICATION_ERROR(-20001, 'N√£o √© permitido excluir um aluno com status de matr√≠cula "Ativo". Altere o status para "Inativo" ou "Concluido" primeiro.');
  END IF;
END;
/

-- Testando o Trigger:
-- Primeiro, insira um aluno ativo (se n√£o tiver)
INSERT INTO ALUNOS (ID, NOME, EMAIL, STATUS_MATRICULA) VALUES (101, 'Aluno Teste', 'teste@email.com', 'Ativo');
COMMIT;

-- Tentar excluir um aluno ativo (deve dar erro)
DELETE FROM ALUNOS WHERE ID = 101 AND STATUS_MATRICULA = 'Ativo';

-- Altere o status e tente novamente (deve funcionar)
UPDATE ALUNOS SET STATUS_MATRICULA = 'Inativo' WHERE ID = 101;
COMMIT;
DELETE FROM ALUNOS WHERE ID = 101;
COMMIT;
          </code></pre>
        </div>
      </div>

      <div class="sub-section">
        <h2>5Ô∏è‚É£ Abstra√ß√£o e Seguran√ßa: Views <i class="fas fa-eye"></i></h2>
        <blockquote>
          <p>Uma view √© uma tabela virtual baseada no resultado de uma instru√ß√£o SQL. Uma view cont√©m linhas e colunas,
            como uma tabela real, mas os dados n√£o s√£o armazenados nela; s√£o derivados das tabelas base cada vez que a
            view √© acessada. Views s√£o usadas para simplificar consultas complexas, fornecer seguran√ßa (mostrando apenas
            certas colunas ou linhas) e abstrair a complexidade do esquema subjacente.</p>
        </blockquote>
        <div class="card">
          <h3>5.1. <code>CREATE VIEW</code>: Criar uma View</h3>
          <p>Define uma view com base em uma consulta SQL. A view n√£o armazena dados, apenas a defini√ß√£o da consulta.
            Quando a view √© consultada, a consulta subjacente √© executada.</p>
          <pre><code class="language-sql">
-- Criar uma view de alunos com suas m√©dias de notas
-- Assumindo que ALUNOS (ID, NOME) e NOTAS (ALUNO_ID, NOTA) existam.
-- Exemplo de cria√ß√£o das tabelas para teste:
-- CREATE TABLE ALUNOS (ID NUMBER PRIMARY KEY, NOME VARCHAR2(100), EMAIL VARCHAR2(100), STATUS_MATRICULA VARCHAR2(20));
-- CREATE TABLE NOTAS (NOTA_ID NUMBER PRIMARY KEY, ALUNO_ID NUMBER, DISCIPLINA VARCHAR2(50), NOTA NUMBER, TURMA_ID NUMBER);
-- CREATE TABLE TURMAS (ID NUMBER PRIMARY KEY, NOME_TURMA VARCHAR2(50));
-- INSERT INTO ALUNOS VALUES (1, 'Jo√£o Silva', 'joao@email.com', 'Ativo');
-- INSERT INTO ALUNOS VALUES (2, 'Maria Souza', 'maria@email.com', 'Ativo');
-- INSERT INTO NOTAS VALUES (1, 1, 'Matem√°tica', 8.5, 101);
-- INSERT INTO NOTAS VALUES (2, 1, 'Portugu√™s', 7.0, 101);
-- INSERT INTO NOTAS VALUES (3, 2, 'Matem√°tica', 9.0, 102);
-- INSERT INTO TURMAS VALUES (101, 'Turma A');
-- INSERT INTO TURMAS VALUES (102, 'Turma B');
-- COMMIT;

CREATE VIEW VW_ALUNOS_MEDIA_NOTAS AS
SELECT A.NOME, AVG(N.NOTA) AS MEDIA_NOTA
FROM ALUNOS A
JOIN NOTAS N ON A.ID = N.ALUNO_ID
GROUP BY A.NOME;

-- Exemplo de uso da view: Consultar alunos com m√©dia de notas superior a 7
SELECT NOME, MEDIA_NOTA FROM VW_ALUNOS_MEDIA_NOTAS WHERE MEDIA_NOTA > 7;

-- Outro exemplo: View para mostrar apenas informa√ß√µes sens√≠veis de alunos para um usu√°rio espec√≠fico
CREATE VIEW VW_ALUNOS_INFO_BASICA AS
SELECT ID, NOME, EMAIL
FROM ALUNOS
WHERE STATUS_MATRICULA = 'Ativo'; -- Supondo uma coluna STATUS_MATRICULA
          </code></pre>

          <h3>5.2. <code>DROP VIEW</code>: Remover uma View</h3>
          <p>Remove a defini√ß√£o da view do banco de dados. Isso n√£o afeta as tabelas base subjacentes.</p>
          <pre><code class="language-sql">
DROP VIEW VW_ALUNOS_MEDIA_NOTAS;
          </code></pre>

          <h3>5.3. Views Atualiz√°veis</h3>
          <p>Views podem ser usadas para inserir, atualizar e excluir dados nas tabelas base, desde que certas condi√ß√µes
            sejam atendidas. Uma view √© consider√°vel "atualiz√°vel" (ou "simples") se a opera√ß√£o de DML puder ser
            claramente mapeada para uma √∫nica tabela base. Condi√ß√µes que geralmente tornam uma view n√£o-atualiz√°vel
            incluem:</p>
          <ul>
            <li>Uso de fun√ß√µes de agrega√ß√£o (`AVG`, `COUNT`, `SUM`, etc.).</li>
            <li>Cl√°usula `GROUP BY`.</li>
            <li>Cl√°usula `DISTINCT`.</li>
            <li>Cl√°usula `UNION`, `UNION ALL`, `INTERSECT`, `MINUS`.</li>
            <li>Subconsultas na lista `SELECT` que retornam m√∫ltiplas colunas ou usam fun√ß√µes de agrega√ß√£o.</li>
            <li>Joins com m√∫ltiplas tabelas (em alguns SGBDs, views com joins podem ser atualiz√°veis sob certas
              condi√ß√µes, mas com restri√ß√µes).</li>
            <li>Colunas derivadas (ex: `PRECO * QUANTIDADE`).</li>
          </ul>
          <pre><code class="language-sql">
-- Criar uma view simples de uma tabela
-- Para teste, vamos criar uma tabela PRODUTOS:
-- CREATE TABLE PRODUTOS (PRODUTO_ID NUMBER PRIMARY KEY, NOME VARCHAR2(100), PRECO NUMBER, ESTOQUE NUMBER DEFAULT 0);
-- INSERT INTO PRODUTOS VALUES (1, 'Teclado', 150, 10);
-- INSERT INTO PRODUTOS VALUES (2, 'Mouse', 80, 20);
-- COMMIT;

CREATE VIEW VW_PRODUTOS_SIMPLES AS
SELECT PRODUTO_ID, NOME, PRECO
FROM PRODUTOS
WHERE PRECO > 100;

-- Inserir atrav√©s da view (se a view for atualiz√°vel e a coluna obrigat√≥ria estiver presente)
-- Note: O produto com PRECO <= 100 n√£o aparecer√° na view, mas ser√° inserido na tabela base.
-- Para que a inser√ß√£o funcione, todas as colunas NOT NULL da tabela base que n√£o possuem DEFAULT devem ser fornecidas,
-- ou a view deve incluir essas colunas.
-- Se PRODUTO_ID for PRIMARY KEY e n√£o tiver uma sequence/trigger para preenchimento, precisaria ser fornecido.
INSERT INTO VW_PRODUTOS_SIMPLES (PRODUTO_ID, NOME, PRECO) VALUES (3, 'Monitor', 950);
INSERT INTO VW_PRODUTOS_SIMPLES (PRODUTO_ID, NOME, PRECO) VALUES (4, 'Webcam', 90); -- N√£o aparecer√° na view, mas ser√° inserido na tabela PRODUTOS
COMMIT;

-- Atualizar atrav√©s da view
UPDATE VW_PRODUTOS_SIMPLES SET PRECO = 160 WHERE PRODUTO_ID = 1;
COMMIT;

-- Deletar atrav√©s da view
DELETE FROM VW_PRODUTOS_SIMPLES WHERE PRODUTO_ID = 2; -- Este DELETE n√£o afetar√° nenhuma linha pela view pois PRECO=80 n√£o √© >100, mas se fosse uma linha da view, funcionaria.
-- Exemplo de DELETE que funcionaria (se o produto 3 fosse deletado):
-- DELETE FROM VW_PRODUTOS_SIMPLES WHERE PRODUTO_ID = 3;
COMMIT;

-- Verifique a tabela base para ver as altera√ß√µes
-- SELECT * FROM PRODUTOS;
          </code></pre>
          <p>Mesmo que uma view seja atualiz√°vel, a cl√°usula `WHERE` da view pode impedir que algumas opera√ß√µes DML
            sejam vis√≠veis atrav√©s dela, como demonstrado no exemplo da `Webcam` e o `DELETE` do `Mouse`. A opera√ß√£o DML
            ocorre na tabela base, e a view apenas reflete o subconjunto de dados que satisfazem sua condi√ß√£o.</p>
        </div>
      </div>

      <div class="exercise">
        <h2>Exerc√≠cios e Desafios <i class="fas fa-question-circle"></i></h2>
        <p>Para solidificar seu aprendizado, tente resolver os seguintes desafios:</p>
        <div class="card">
          <ol>
            <li>
              Crie uma procedure chamada `CALCULAR_E_EXIBIR_MEDIA_TURMA` que receba o `ID_TURMA` como par√¢metro de
              entrada e exiba no console a m√©dia das notas de todos os alunos daquela turma. Se a turma n√£o existir ou
              n√£o tiver notas, exiba uma mensagem apropriada usando `DBMS_OUTPUT.PUT_LINE` e `RAISE_APPLICATION_ERROR`
              se a turma n√£o existir.
              <button onclick="toggleAnswer('ansEx1')">Mostrar Gabarito</button>
              <div class="answer" id="ansEx1">
                <pre><code class="language-sql">
CREATE OR REPLACE PROCEDURE CALCULAR_E_EXIBIR_MEDIA_TURMA (
  p_turma_id IN TURMAS.ID%TYPE
)
IS
  v_media_turma NUMBER;
  v_turma_existe NUMBER;
BEGIN
  -- Primeiro, verifica se a turma existe
  SELECT COUNT(*) INTO v_turma_existe
  FROM TURMAS
  WHERE ID = p_turma_id;

  IF v_turma_existe = 0 THEN
    DBMS_OUTPUT.PUT_LINE('Erro: Turma com ID ' || p_turma_id || ' n√£o encontrada.');
    RAISE_APPLICATION_ERROR(-20001, 'Turma n√£o encontrada para o ID fornecido.');
  END IF;

  -- Calcula a m√©dia das notas para a turma
  SELECT AVG(N.NOTA) INTO v_media_turma
  FROM NOTAS N
  WHERE N.TURMA_ID = p_turma_id;

  IF v_media_turma IS NULL THEN
    DBMS_OUTPUT.PUT_LINE('Turma ' || p_turma_id || ' n√£o possui notas registradas.');
  ELSE
    DBMS_OUTPUT.PUT_LINE('A m√©dia das notas da turma ' || p_turma_id || ' √©: ' || ROUND(v_media_turma, 2));
  END IF;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Ocorreu um erro ao calcular a m√©dia da turma: ' || SQLERRM);
    RAISE; -- Re-lan√ßa a exce√ß√£o original
END;
/

-- Teste:
SET SERVEROUTPUT ON;
-- Certifique-se de que as tabelas ALUNOS, NOTAS e TURMAS existam e tenham dados para teste.
-- Ex: INSERT INTO TURMAS (ID, NOME_TURMA) VALUES (101, 'Turma A');
-- Ex: INSERT INTO NOTAS (NOTA_ID, ALUNO_ID, DISCIPLINA, NOTA, TURMA_ID) VALUES (1, 1, 'Matem√°tica', 8.5, 101);
-- EXEC CALCULAR_E_EXIBIR_MEDIA_TURMA(101); -- Substitua 101 por um ID de turma v√°lido
-- EXEC CALCULAR_E_EXIBIR_MEDIA_TURMA(999); -- Teste com ID de turma inexistente (deve lan√ßar erro)
                </code></pre>
              </div>
            </li>
            <li>
              Crie uma fun√ß√£o chamada `GET_QTD_ALUNOS_POR_CIDADE` que receba o nome de uma cidade (`VARCHAR2`) e retorne
              o n√∫mero total de alunos cadastrados naquela cidade. Se a cidade n√£o tiver alunos, a fun√ß√£o deve retornar
              0. Use `DBMS_OUTPUT.PUT_LINE` para depura√ß√£o se necess√°rio.
              <button onclick="toggleAnswer('ansEx2')">Mostrar Gabarito</button>
              <div class="answer" id="ansEx2">
                <pre><code class="language-sql">
CREATE OR REPLACE FUNCTION GET_QTD_ALUNOS_POR_CIDADE (
  p_cidade IN ALUNOS.CIDADE%TYPE
)
RETURN NUMBER
IS
  v_qtd_alunos NUMBER := 0;
BEGIN
  SELECT COUNT(ID) INTO v_qtd_alunos
  FROM ALUNOS
  WHERE CIDADE = p_cidade;

  DBMS_OUTPUT.PUT_LINE('DEBUG: Contagem de alunos para a cidade ' || p_cidade || ': ' || v_qtd_alunos); -- Linha de depura√ß√£o

  RETURN v_qtd_alunos;

EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('Erro ao contar alunos na cidade: ' || SQLERRM);
    RETURN NULL; -- Ou levante a exce√ß√£o
END;
/

-- Teste:
SET SERVEROUTPUT ON;
DECLARE
  v_total NUMBER;
BEGIN
  -- Assumindo que voc√™ tem dados na tabela ALUNOS, por exemplo:
  -- ALTER TABLE ALUNOS ADD CIDADE VARCHAR2(100);
  -- UPDATE ALUNOS SET CIDADE = 'Recife' WHERE ID = 1;
  -- INSERT INTO ALUNOS (ID, NOME, CIDADE) VALUES (4, 'Julia', 'Recife');
  -- INSERT INTO ALUNOS (ID, NOME, CIDADE) VALUES (5, 'Pedro', 'S√£o Paulo');
  -- COMMIT;

  v_total := GET_QTD_ALUNOS_POR_CIDADE('Recife'); -- Substitua 'Recife' por uma cidade v√°lida
  DBMS_OUTPUT.PUT_LINE('Total de alunos em Recife: ' || v_total);

  v_total := GET_QTD_ALUNOS_POR_CIDADE('Cidade Inexistente');
  DBMS_OUTPUT.PUT_LINE('Total de alunos em Cidade Inexistente: ' || v_total);
END;
/

-- Teste em SQL:
-- SELECT CIDADE, GET_QTD_ALUNOS_POR_CIDADE(CIDADE) AS TotalAlunos
-- FROM ALUNOS
-- GROUP BY CIDADE;
                </code></pre>
              </div>
            </li>
            <li>
              Crie um trigger `BEFORE INSERT` na tabela `NOTAS` que, antes de inserir uma nova nota, verifique se a nota
              est√° entre 0 e 10. Se n√£o estiver, o trigger deve levantar uma exce√ß√£o (`RAISE_APPLICATION_ERROR`)
              impedindo a inser√ß√£o e exibir uma mensagem de erro usando `DBMS_OUTPUT.PUT_LINE`.
              <button onclick="toggleAnswer('ansEx3')">Mostrar Gabarito</button>
              <div class="answer" id="ansEx3">
                <pre><code class="language-sql">
CREATE OR REPLACE TRIGGER TRG_VALIDAR_NOTA
BEFORE INSERT ON NOTAS
FOR EACH ROW
BEGIN
  IF :NEW.NOTA < 0 OR :NEW.NOTA > 10 THEN
    DBMS_OUTPUT.PUT_LINE('Erro de Valida√ß√£o: A nota ' || :NEW.NOTA || ' est√° fora do intervalo permitido (0-10).');
    RAISE_APPLICATION_ERROR(-20002, 'A nota deve estar entre 0 e 10.');
  END IF;
END;
/

-- Teste:
SET SERVEROUTPUT ON; -- Certifique-se de que a sa√≠da do servidor est√° ativada

-- Assumindo que voc√™ tem a tabela NOTAS e uma sequence SEQ_NOTAS_ID para o ID:
-- CREATE TABLE NOTAS (ID NUMBER PRIMARY KEY, ALUNO_ID NUMBER, DISCIPLINA VARCHAR2(50), NOTA NUMBER);
-- CREATE SEQUENCE SEQ_NOTAS_ID START WITH 1 INCREMENT BY 1;
-- INSERT INTO ALUNOS (ID, NOME) VALUES (1, 'Joana'); -- Inserir um aluno para FK
-- COMMIT;

-- Deve funcionar
INSERT INTO NOTAS (ID, ALUNO_ID, DISCIPLINA, NOTA) VALUES (SEQ_NOTAS_ID.NEXTVAL, 1, 'Geografia', 7.5);
COMMIT;

-- Deve dar erro (aqui a sa√≠da do DBMS_OUTPUT aparecer√° antes da exce√ß√£o)
INSERT INTO NOTAS (ID, ALUNO_ID, DISCIPLINA, NOTA) VALUES (SEQ_NOTAS_ID.NEXTVAL, 1, 'Geografia', 11);
COMMIT; -- Este COMMIT n√£o ser√° executado devido ao erro
                </code></pre>
              </div>
            </li>
            <li>
              Crie uma view chamada <code>VW_COLABORADORES_ATUAIS</code> que selecione <code>nome</code>,
              <code>cargo</code> e <code>data_contratacao</code> da tabela <code>Colaboradores_Ex</code>, mas apenas
              para funcion√°rios contratados ap√≥s '2023-01-01' (use `TO_DATE`).
              Em seguida, insira um novo colaborador atrav√©s desta view (se for poss√≠vel, caso contr√°rio, explique por
              que n√£o).
              <button onclick="toggleAnswer('ansEx4')">Mostrar Gabarito</button>
              <div class="answer" id="ansEx4">
                <pre><code class="language-sql">
-- Para este exerc√≠cio, vamos re-criar a tabela Colaboradores_Ex e inserir alguns dados
-- para garantir que a view funcione.
-- DROP TABLE Colaboradores_Ex CASCADE CONSTRAINTS;
-- DROP SEQUENCE SEQ_FUNCIONARIOS_ID;

CREATE TABLE Colaboradores_Ex (
    funcionario_id NUMBER PRIMARY KEY,
    nome VARCHAR2(100),
    cargo VARCHAR2(100) NOT NULL,
    data_contratacao DATE DEFAULT SYSDATE
);

CREATE SEQUENCE SEQ_FUNCIONARIOS_ID START WITH 1 INCREMENT BY 1;

INSERT INTO Colaboradores_Ex (funcionario_id, nome, cargo, data_contratacao) VALUES (SEQ_FUNCIONARIOS_ID.NEXTVAL, 'Ana Silva', 'Desenvolvedor', TO_DATE('2024-01-10', 'YYYY-MM-DD'));
INSERT INTO Colaboradores_Ex (funcionario_id, nome, cargo, data_contratacao) VALUES (SEQ_FUNCIONARIOS_ID.NEXTVAL, 'Beto Costa', 'Analista', TO_DATE('2022-05-20', 'YYYY-MM-DD'));
INSERT INTO Colaboradores_Ex (funcionario_id, nome, cargo, data_contratacao) VALUES (SEQ_FUNCIONARIOS_ID.NEXTVAL, 'Carla Lima', 'Gerente', TO_DATE('2023-07-01', 'YYYY-MM-DD'));
COMMIT;

-- 1. Criar a view
CREATE OR REPLACE VIEW VW_COLABORADORES_ATUAIS AS
SELECT funcionario_id, nome, cargo, data_contratacao -- Inclua a PK para possibilitar a inser√ß√£o se n√£o houver DEFAULT ou SEQUENCE na tabela base
FROM Colaboradores_Ex
WHERE data_contratacao > TO_DATE('2023-01-01', 'YYYY-MM-DD');

-- 2. Inserir um novo funcion√°rio atrav√©s da view
-- Explica√ß√£o: Esta view √© atualiz√°vel porque seleciona colunas de uma √∫nica tabela
-- e n√£o possui fun√ß√µes de agrega√ß√£o, GROUP BY, etc.
-- Ao incluir o `funcionario_id` na view, podemos fornecer um valor para a PK.
-- Se a PK tivesse uma SEQUENCE ou DEFAULT na tabela base, a PK n√£o precisaria estar na view para INSERT.

INSERT INTO VW_COLABORADORES_ATUAIS (funcionario_id, nome, cargo, data_contratacao)
VALUES (SEQ_FUNCIONARIOS_ID.NEXTVAL, 'Daniel Souza', 'DBA Junior', TO_DATE('2024-05-20', 'YYYY-MM-DD'));
COMMIT;

-- Verificar a view e a tabela base
-- SELECT * FROM VW_COLABORADORES_ATUAIS;
-- SELECT * FROM Colaboradores_Ex;
                </code></pre>
              </div>
            </li>
          </ol>
        </div>
      </div>

    </div>

  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function () {

      const hamburgerMenu = document.getElementById('hamburger-menu');
      const sidebar = document.getElementById('sidebar');
      const content = document.getElementById('content');
      const overlay = document.getElementById('overlay');
      const sidebarLinks = sidebar.querySelectorAll('a');

      function toggleSidebar() {
        sidebar.classList.toggle('active');
        content.classList.toggle('sidebar-active');
        overlay.classList.toggle('active');
      }

      // Adiciona event listeners AP√ìS os elementos serem garantidamente carregados no DOM
      if (hamburgerMenu) {
        hamburgerMenu.addEventListener('click', toggleSidebar);
      } else {
        console.warn('Elemento #hamburger-menu n√£o encontrado. Verifique o HTML.');
      }

      if (overlay) {
        overlay.addEventListener('click', toggleSidebar);
      } else {
        console.warn('Elemento #overlay n√£o encontrado. Verifique o HTML.');
      }


      sidebarLinks.forEach(link => {
        link.addEventListener('click', function () {
          if (sidebar.classList.contains('active')) {
            toggleSidebar();
          }
        });
      });

      function highlightActiveLink() {
        const currentPathname = window.location.pathname;
        let currentFileName = currentPathname.split('/').pop();

        // Se a URL termina em '/', o arquivo atual √© 'index.html'
        if (currentFileName === '' || currentFileName === 'aulas_sql') { // Adicionado 'aulas_sql' caso a URL base seja s√≥ o nome do repo
          currentFileName = 'index.html';
        }

        sidebarLinks.forEach(link => {
          const linkHref = link.getAttribute('href');

          link.classList.remove('active'); // Remove de todos primeiro

          // L√≥gica para marcar o link ativo
          if (linkHref === currentFileName || (currentFileName === 'index.html' && linkHref === 'index.html')) {
            link.classList.add('active');
          }
        });
      }

      highlightActiveLink(); // Chama a fun√ß√£o ao inicializar a sidebar

      // Fun√ß√£o para mostrar/esconder o gabarito
      window.toggleAnswer = function (id) {
        var x = document.getElementById(id);
        if (x.style.display === "none" || x.style.display === "") {
          x.style.display = "block";
        } else {
          x.style.display = "none";
        }
      };
    });
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-sql.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-markup.min.js"></script>
</body>

</html>